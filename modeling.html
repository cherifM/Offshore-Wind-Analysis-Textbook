<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modeling - Offshore Wind Analysis Textbook</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
</head>
<body>
    <nav class="nav-main">
        <a href="index.html">Home</a>
        <a href="theory.html">Theory</a>
        <a href="measurement.html">Measurements</a>
        <a href="modeling.html" class="active">Modeling</a>
        <a href="data-processing.html">Data Processing</a>
        <a href="case-studies.html">Case Studies</a>
        <a href="advanced-topics.html">Advanced Topics</a>
        <a href="calculators.html">Calculators</a>
        <a href="exercises.html">Exercises</a>
        <a href="formulas.html">Formulas</a>
        <a href="glossary.html">Glossary</a>
        <a href="references.html">References</a>
        <a href="datasets.html">Datasets</a>
    </nav>

    <div class="header">
        <h1>üåä Numerical Modeling & Simulations</h1>
        <p>From Mesoscale to Microscale Wind Modeling</p>
    </div>

    <div class="container">
        <!-- Chapter Overview -->
        <div class="section">
            <h2>üìö Chapter Overview</h2>
            <div class="card-grid">
                <div class="card">
                    <h3>Part I: Atmospheric Modeling</h3>
                    <ul>
                        <li><strong>Scale Hierarchy</strong>
                            <ul>
                                <li><a href="#nwp">1. Global/Mesoscale (NWP)</a></li>
                                <li><a href="#mesoscale">2. Regional (WRF)</a></li>
                                <li><a href="#microscale">3. Local (CFD/LES)</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="card">
                    <h3>Part II: Wind Farm Modeling</h3>
                    <ul>
                        <li><strong>Engineering Models</strong>
                            <ul>
                                <li><a href="#wake">4. Wake Models</a></li>
                                <li><a href="#floris-section">- FLORIS Framework</a></li>
                            </ul>
                        </li>
                        <li><strong>Applications</strong>
                            <ul>
                                <li><a href="#layout">5. Layout Optimization</a></li>
                                <li><a href="#aep">6. Energy Production</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="card">
                    <h3>Part III: Advanced Methods</h3>
                    <ul>
                        <li><strong>Integration</strong>
                            <ul>
                                <li><a href="#coupling">7. Model Coupling</a></li>
                                <li><a href="#openfoam-section">- OpenFOAM LES</a></li>
                            </ul>
                        </li>
                        <li><strong>Best Practices</strong>
                            <ul>
                                <li><a href="#uncertainty">8. Uncertainty</a></li>
                                <li><a href="#validation">9. Validation</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- ========== PART I: ATMOSPHERIC MODELING ========== -->
        <div class="section part-divider">
            <h2 style="text-align: center; color: #0066cc; font-size: 2em; margin: 40px 0;">Part I: Atmospheric Modeling</h2>
            <p style="text-align: center; font-style: italic; margin-bottom: 40px;">From global weather patterns to local wind conditions</p>
        </div>

        <!-- Section 1: NWP -->
        <div class="section" id="nwp">
            <h2>1. Numerical Weather Prediction (NWP)</h2>
            
            <div class="info-box">
                <strong>Definition:</strong> NWP models solve the governing equations of atmospheric motion on a discretized grid to forecast weather conditions.
            </div>

            <h3>1.1 Global NWP Models</h3>
            <table class="table">
                <tr>
                    <th>Model</th>
                    <th>Agency</th>
                    <th>Resolution</th>
                    <th>Forecast Length</th>
                    <th>Updates</th>
                </tr>
                <tr>
                    <td>GFS</td>
                    <td>NOAA/NCEP</td>
                    <td>0.25¬∞ (~28km)</td>
                    <td>16 days</td>
                    <td>4x daily</td>
                </tr>
                <tr>
                    <td>ECMWF IFS</td>
                    <td>ECMWF</td>
                    <td>0.1¬∞ (~9km)</td>
                    <td>10 days</td>
                    <td>2x daily</td>
                </tr>
                <tr>
                    <td>ICON</td>
                    <td>DWD</td>
                    <td>13km</td>
                    <td>7.5 days</td>
                    <td>4x daily</td>
                </tr>
                <tr>
                    <td>ERA5</td>
                    <td>ECMWF</td>
                    <td>0.25¬∞ (~31km)</td>
                    <td>Reanalysis</td>
                    <td>Monthly</td>
                </tr>
            </table>

            <h3>1.2 Governing Equations</h3>
            <div class="formula-large">
                Momentum: ‚àÇu/‚àÇt + u¬∑‚àáu = -1/œÅ ‚àáp - fk√óu + ŒΩ‚àá¬≤u<br>
                Continuity: ‚àÇœÅ/‚àÇt + ‚àá¬∑(œÅu) = 0<br>
                Thermodynamic: ‚àÇŒ∏/‚àÇt + u¬∑‚àáŒ∏ = Q/cp
            </div>

            <h3>1.3 Parameterizations</h3>
            <div class="plot-grid">
                <div class="plot-box">
                    <h4>Grid Resolution Effects</h4>
                    <canvas id="gridResolution"></canvas>
                </div>
                <div class="plot-box">
                    <h4>Subgrid Processes</h4>
                    <ul>
                        <li><strong>PBL schemes:</strong> YSU, MYJ, MYNN</li>
                        <li><strong>Surface layer:</strong> MM5, Eta similarity</li>
                        <li><strong>Land surface:</strong> Noah, CLM</li>
                        <li><strong>Radiation:</strong> RRTM, Dudhia</li>
                        <li><strong>Microphysics:</strong> WSM, Thompson</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section 2: Mesoscale Modeling -->
        <div class="section" id="mesoscale">
            <h2>2. Mesoscale Modeling (WRF)</h2>
            
            <h3>2.1 WRF Model Setup</h3>
            <div class="warning-box">
                <strong>Domain Configuration Best Practices:</strong>
                <ul>
                    <li>Outer domain: 3-9 km resolution, covers synoptic features</li>
                    <li>Middle domain: 1-3 km resolution, captures mesoscale</li>
                    <li>Inner domain: 200m-1km, site-specific details</li>
                    <li>Nesting ratio: 1:3 or 1:5 recommended</li>
                    <li>Buffer zones: >10 grid points from boundaries</li>
                </ul>
            </div>

            <h3>2.2 WRF Domain Example</h3>
            <canvas id="wrfDomains"></canvas>

            <h3>2.3 Offshore-Specific Settings</h3>
            <table class="table">
                <tr>
                    <th>Component</th>
                    <th>Recommended Option</th>
                    <th>Reason</th>
                </tr>
                <tr>
                    <td>PBL Scheme</td>
                    <td>MYNN 2.5/3</td>
                    <td>Better stable conditions</td>
                </tr>
                <tr>
                    <td>Surface Layer</td>
                    <td>MYNN</td>
                    <td>Consistent with PBL</td>
                </tr>
                <tr>
                    <td>SST Update</td>
                    <td>Daily/6-hourly</td>
                    <td>Captures diurnal cycle</td>
                </tr>
                <tr>
                    <td>Sea Surface Roughness</td>
                    <td>Wave-dependent</td>
                    <td>Better momentum flux</td>
                </tr>
                <tr>
                    <td>Vertical Levels</td>
                    <td>>50, enhanced in PBL</td>
                    <td>Resolve shear/veer</td>
                </tr>
            </table>

            <h3>2.4 WRF Output Processing</h3>
            <div class="plot-grid">
                <div class="plot-box">
                    <h4>Hub Height Interpolation</h4>
                    <canvas id="wrfInterpolation"></canvas>
                </div>
                <div class="plot-box">
                    <h4>Temporal Downscaling</h4>
                    <canvas id="temporalDownscale"></canvas>
                </div>
            </div>
        </div>

        <!-- Section 3: Microscale CFD/LES -->
        <div class="section" id="microscale">
            <h2>3. Microscale CFD and LES</h2>
            
            <h3>3.1 CFD Approaches</h3>
            <div class="card-grid">
                <div class="card">
                    <h4>RANS (Reynolds-Averaged)</h4>
                    <ul>
                        <li>Steady-state solution</li>
                        <li>k-Œµ, k-œâ turbulence models</li>
                        <li>Computationally efficient</li>
                        <li>Limited for complex terrain</li>
                    </ul>
                    <p><strong>Use cases:</strong> Simple terrain, preliminary studies</p>
                </div>
                <div class="card">
                    <h4>LES (Large Eddy Simulation)</h4>
                    <ul>
                        <li>Resolves large eddies</li>
                        <li>Time-dependent</li>
                        <li>Captures turbulence</li>
                        <li>Computationally intensive</li>
                    </ul>
                    <p><strong>Use cases:</strong> Complex flows, wake studies</p>
                </div>
                <div class="card">
                    <h4>DES (Detached Eddy)</h4>
                    <ul>
                        <li>Hybrid RANS-LES</li>
                        <li>Efficient compromise</li>
                        <li>Good for wakes</li>
                        <li>Transition challenges</li>
                    </ul>
                    <p><strong>Use cases:</strong> Wind farm simulations</p>
                </div>
            </div>

            <h3>3.2 Domain Setup</h3>
            <div class="info-box">
                <strong>CFD Domain Requirements:</strong>
                <ul>
                    <li>Inlet: 3-5√ó turbine height upstream</li>
                    <li>Outlet: 10-15√ó turbine height downstream</li>
                    <li>Lateral: 5√ó rotor diameter minimum</li>
                    <li>Top: 3-5√ó turbine height (higher for IBL)</li>
                    <li>Cell size at turbine: D/20 to D/10</li>
                </ul>
            </div>

            <h3>3.3 Mesh Refinement</h3>
            <canvas id="meshRefinement"></canvas>

            <h3>3.4 Boundary Conditions</h3>
            <table class="table">
                <tr>
                    <th>Boundary</th>
                    <th>Velocity</th>
                    <th>Turbulence</th>
                    <th>Temperature</th>
                </tr>
                <tr>
                    <td>Inlet</td>
                    <td>Log/power profile</td>
                    <td>k, Œµ profiles</td>
                    <td>Stability profile</td>
                </tr>
                <tr>
                    <td>Outlet</td>
                    <td>Zero gradient</td>
                    <td>Zero gradient</td>
                    <td>Zero gradient</td>
                </tr>
                <tr>
                    <td>Ground</td>
                    <td>Wall function</td>
                    <td>Wall function</td>
                    <td>Fixed or flux</td>
                </tr>
                <tr>
                    <td>Top</td>
                    <td>Slip/symmetry</td>
                    <td>Zero gradient</td>
                    <td>Fixed gradient</td>
                </tr>
                <tr>
                    <td>Lateral</td>
                    <td>Periodic/slip</td>
                    <td>Periodic/slip</td>
                    <td>Periodic/zero gradient</td>
                </tr>
            </table>
            
            <h3>3.5 Turbulence Modeling for Wind Farms</h3>
            
            <div class="info-box">
                <strong>Key Challenge:</strong> Wind farm simulations must capture both atmospheric turbulence and wake-generated turbulence. The choice of turbulence model significantly impacts wake recovery predictions and computational efficiency.
            </div>
            
            <h4>Why Turbulence Modeling Matters</h4>
            <div class="plot-grid">
                <div class="plot-box">
                    <canvas id="turbulenceEvolution"></canvas>
                </div>
                <div class="plot-box">
                    <h4>Turbulence Sources in Wind Farms</h4>
                    <ul>
                        <li><strong>Atmospheric:</strong> Natural boundary layer turbulence</li>
                        <li><strong>Mechanical:</strong> Turbine-generated shear</li>
                        <li><strong>Thermal:</strong> Buoyancy effects (stability)</li>
                        <li><strong>Wake:</strong> Tip vortices and hub vortex</li>
                    </ul>
                </div>
            </div>
            
            <h4>The k-epsilon-fP Model</h4>
            <div class="formula-large">
                ‚àÇk/‚àÇt + U¬∑‚àák = ‚àá¬∑[(ŒΩ + ŒΩt/œÉk)‚àák] + Pk - Œµ + Sk<br>
                ‚àÇŒµ/‚àÇt + U¬∑‚àáŒµ = ‚àá¬∑[(ŒΩ + ŒΩt/œÉŒµ)‚àáŒµ] + C1Œµ(Œµ/k)Pk - C2Œµ(Œµ¬≤/k) + SŒµ<br>
                <br>
                where: fP = 1 + (C3Œµ - 1)¬∑max(0, Pk/Œµ - 1)
            </div>
            
            <div class="warning-box">
                <strong>k-epsilon-fP (Freitas-Prandtl modification):</strong>
                <p>This model adds a modification factor (fP) to the standard k-epsilon model specifically designed to improve predictions when strong source terms are present - exactly what happens with actuator disc models!</p>
            </div>
            
            <h4>Why k-epsilon-fP for Actuator Disc Models?</h4>
            <div class="card-grid">
                <div class="card">
                    <h4>‚úÖ Advantages</h4>
                    <ul>
                        <li><strong>Wake Recovery:</strong> Better prediction of turbulence generation behind discs</li>
                        <li><strong>Stability:</strong> Handles strong source terms without numerical issues</li>
                        <li><strong>Efficiency:</strong> Only 2 additional equations (k and Œµ)</li>
                        <li><strong>Calibration:</strong> Well-validated for wind turbine wakes</li>
                        <li><strong>Far Wake:</strong> Good prediction of wake meandering</li>
                    </ul>
                </div>
                <div class="card">
                    <h4>‚ùå Limitations</h4>
                    <ul>
                        <li><strong>Near Wall:</strong> Less accurate than k-omega models</li>
                        <li><strong>Anisotropy:</strong> Assumes isotropic turbulence</li>
                        <li><strong>Very Near Wake:</strong> May miss detailed vortex structures</li>
                        <li><strong>Transition:</strong> Cannot predict laminar-turbulent transition</li>
                    </ul>
                </div>
            </div>
            
            <h4>k-omega-SST Alternative</h4>
            <div class="info-box">
                <strong>When to consider k-omega-SST:</strong>
                <ul>
                    <li>Complex terrain with significant wall effects</li>
                    <li>Detailed blade-resolved simulations</li>
                    <li>Strong adverse pressure gradients</li>
                    <li>Need for accurate boundary layer resolution</li>
                </ul>
                
                <p><strong>Why k-epsilon-fP usually wins for wind farms:</strong></p>
                <ul>
                    <li>Actuator discs don't have walls - k-omega's advantage is lost</li>
                    <li>k-omega-SST can be overly dissipative in free shear flows</li>
                    <li>More complex (4 equations vs 2) with little benefit for wakes</li>
                    <li>k-epsilon-fP is specifically tuned for actuator forcing</li>
                </ul>
            </div>
            
            <h4>Practical Implementation</h4>
            <div class="code-block">
                <pre><code>// OpenFOAM turbulence model setup for wind farms
// constant/turbulenceProperties
simulationType  RAS;  // Reynolds-Averaged Simulation

RAS
{
    RASModel        kEpsilonFP;  // Freitas-Prandtl variant
    
    turbulence      on;
    printCoeffs     on;
    
    kEpsilonFPCoeffs
    {
        // Standard k-epsilon constants
        Cmu             0.09;
        C1              1.44;
        C2              1.92;
        C3              0.8;    // Buoyancy term
        sigmak          1.0;
        sigmaEps        1.3;
        
        // Actuator disc enhancement
        Prt             0.85;   // Turbulent Prandtl number
        
        // fP limiter for stability
        fPMax           1.5;    // Maximum enhancement factor
    }
}

// Initial conditions for atmospheric boundary layer
// 0/k
dimensions      [0 2 -2 0 0 0 0];
internalField   uniform 0.5;  // k = 1.5*(U*I)^2, I~0.1

boundaryField
{
    inlet
    {
        type            atmBoundaryLayerInletK;
        Uref            8.0;
        Zref            90.0;
        z0              0.0002;
        value           $internalField;
    }
}

// 0/epsilon
dimensions      [0 2 -3 0 0 0 0];
internalField   uniform 0.01;

boundaryField
{
    inlet
    {
        type            atmBoundaryLayerInletEpsilon;
        Uref            8.0;
        Zref            90.0;
        z0              0.0002;
        value           $internalField;
    }
}</code></pre>
            </div>
            
            <h4>Turbulence Model Comparison</h4>
            <canvas id="turbulenceComparison"></canvas>
            
            <h4>Best Practices for Wind Farm Simulations</h4>
            <div class="success-box">
                <ol>
                    <li><strong>Model Selection:</strong>
                        <ul>
                            <li>Use k-epsilon-fP for actuator disc/line models</li>
                            <li>Consider k-omega-SST only for blade-resolved or complex terrain</li>
                            <li>LES for research and detailed wake studies</li>
                        </ul>
                    </li>
                    <li><strong>Initialization:</strong>
                        <ul>
                            <li>Set k based on turbulence intensity: k = 1.5(UI)¬≤</li>
                            <li>Calculate Œµ from mixing length: Œµ = C_Œº^(3/4) k^(3/2) / l</li>
                            <li>Use atmospheric profiles at inlet</li>
                        </ul>
                    </li>
                    <li><strong>Numerical Settings:</strong>
                        <ul>
                            <li>Use bounded schemes for k and Œµ transport</li>
                            <li>Under-relax turbulence equations (0.7 typical)</li>
                            <li>Monitor turbulence generation in wake</li>
                        </ul>
                    </li>
                    <li><strong>Validation:</strong>
                        <ul>
                            <li>Compare TI profiles with measurements</li>
                            <li>Check wake recovery against field data</li>
                            <li>Verify mass and momentum conservation</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </div>

        <!-- ========== PART II: WIND FARM MODELING ========== -->
        <div class="section part-divider">
            <h2 style="text-align: center; color: #0066cc; font-size: 2em; margin: 40px 0;">Part II: Wind Farm Modeling</h2>
            <p style="text-align: center; font-style: italic; margin-bottom: 40px;">Engineering models for wind farm design and optimization</p>
        </div>

        <!-- Section 4: Wake Modeling -->
        <div class="section" id="wake">
            <h2>4. Wake Modeling</h2>
            
            <h3>4.1 Wake Characteristics</h3>
            <div class="plot-grid">
                <div class="plot-box">
                    <h4>Wake Velocity Deficit</h4>
                    <canvas id="wakeDeficit"></canvas>
                </div>
                <div class="plot-box">
                    <h4>Wake Expansion</h4>
                    <canvas id="wakeExpansion"></canvas>
                </div>
            </div>

            <h3>4.2 Engineering Wake Models</h3>
            <div class="card-grid">
                <div class="card">
                    <h4>Jensen Model</h4>
                    <div class="formula">
                        V = V‚ÇÄ[1 - 2a/(1 + kx/r‚ÇÄ)¬≤]
                    </div>
                    <ul>
                        <li>Linear expansion</li>
                        <li>Top-hat profile</li>
                        <li>Simple, fast</li>
                        <li>Conservative</li>
                    </ul>
                </div>
                <div class="card">
                    <h4>Gaussian Models</h4>
                    <div class="formula">
                        V = V‚ÇÄ[1 - C(x)exp(-r¬≤/2œÉ¬≤)]
                    </div>
                    <ul>
                        <li>Realistic profile</li>
                        <li>Variable expansion</li>
                        <li>Better accuracy</li>
                        <li>More parameters</li>
                    </ul>
                </div>
                <div class="card">
                    <h4>Dynamic Models</h4>
                    <ul>
                        <li>DWM (Dynamic Wake)</li>
                        <li>Time-varying</li>
                        <li>Meandering effects</li>
                        <li>Fatigue loads</li>
                    </ul>
                </div>
            </div>

            <h3>4.3 Wake Superposition</h3>
            <div class="warning-box">
                <strong>Superposition Methods:</strong>
                <ul>
                    <li><strong>Linear:</strong> Œ¥V_total = Œ£ Œ¥V_i (conservative)</li>
                    <li><strong>Sum of squares:</strong> Œ¥V_total = ‚àö(Œ£ Œ¥V_i¬≤) (common)</li>
                    <li><strong>Maximum:</strong> Œ¥V_total = max(Œ¥V_i) (optimistic)</li>
                    <li><strong>Momentum:</strong> Conservation-based (physical)</li>
                </ul>
            </div>

            <h3>4.4 Wake Model Comparison</h3>
            <canvas id="wakeComparison"></canvas>
        </div>

        <!-- FLORIS Integration Section -->
        <div class="model-section" id="floris-section">
            <h3>4.5 FLORIS Wake Modeling Framework</h3>
            
            <h4>FLORIS Implementation Example</h4>
            <div class="code-block">
                <pre><code># FLORIS Python implementation for wake analysis
import floris.tools as wfct
import numpy as np
import matplotlib.pyplot as plt

# Initialize FLORIS model
fi = wfct.floris_interface.FlorisInterface("floris_input.yaml")

# Define wind farm layout
layout_x = [0, 840, 1680, 2520, 3360]  # 7D spacing
layout_y = [0, 0, 0, 0, 0]
fi.reinitialize(layout=(layout_x, layout_y))

# Set atmospheric conditions
wind_speeds = np.arange(3, 26, 1)
wind_directions = np.arange(0, 360, 10)
turbulence_intensities = [0.06, 0.08, 0.10]  # Low, medium, high TI

# Calculate wake effects for different conditions
results = []
for ws in wind_speeds:
    for wd in wind_directions:
        for ti in turbulence_intensities:
            fi.reinitialize(wind_speed=[ws], 
                          wind_direction=[wd],
                          turbulence_intensity=[ti])
            fi.calculate_wake()
            
            # Get turbine powers
            powers = fi.get_turbine_powers() / 1e6  # MW
            
            results.append({
                'ws': ws, 'wd': wd, 'ti': ti,
                'powers': powers,
                'total_power': np.sum(powers),
                'wake_losses': 1 - np.sum(powers) / (len(powers) * powers[0])
            })

# Analyze wake steering potential
def optimize_yaw_angles(fi, wind_speed, wind_direction):
    """Optimize yaw angles for wake steering"""
    from scipy.optimize import minimize
    
    fi.reinitialize(wind_speed=[wind_speed], 
                   wind_direction=[wind_direction])
    
    def objective(yaw_angles):
        fi.calculate_wake(yaw_angles=yaw_angles.reshape(1, -1))
        return -fi.get_farm_power()  # Negative for maximization
    
    # Initial guess: no yaw
    x0 = np.zeros(len(layout_x))
    
    # Bounds: ¬±25 degrees yaw
    bounds = [(-25, 25)] * len(layout_x)
    
    # Optimize
    result = minimize(objective, x0, bounds=bounds, method='L-BFGS-B')
    
    return result.x, -result.fun

# Example: Optimize for specific condition
opt_yaw, opt_power = optimize_yaw_angles(fi, 8.0, 270.0)
print(f"Optimal yaw angles: {opt_yaw}")
print(f"Power improvement: {opt_power/1e6:.2f} MW")</code></pre>
            </div>
            
            <h4>FLORIS Configuration File</h4>
            <div class="code-block">
                <pre><code># floris_input.yaml
logging:
  console:
    enable: true
    level: WARNING
  file:
    enable: false

solver:
  type: turbine_grid
  turbine_grid_points: 3

farm:
  layout_x: []
  layout_y: []
  turbine_type:
    - nrel_5MW

flow_field:
  air_density: 1.225
  reference_wind_height: 90.0
  turbulence_intensity: 0.06
  wind_directions: [270.0]
  wind_shear: 0.07  # Power law exponent for offshore
  wind_speeds: [8.0]
  wind_veer: 0.0

wake:
  model_strings:
    combination_model: sosfs
    deflection_model: gauss
    turbulence_model: crespo_hernandez
    velocity_model: gauss
  
  enable_secondary_steering: true
  enable_yaw_added_recovery: true
  enable_transverse_velocities: true
  
  wake_deflection_parameters:
    gauss:
      ad: 0.0
      alpha: 0.58
      bd: 0.0
      beta: 0.077
      dm: 1.0
      ka: 0.38
      kb: 0.004
  
  wake_velocity_parameters:
    gauss:
      alpha: 0.58
      beta: 0.077
      ka: 0.38
      kb: 0.004
  
  wake_turbulence_parameters:
    crespo_hernandez:
      initial: 0.1
      constant: 0.5
      ai: 0.8
      downstream: -0.32</code></pre>
            </div>
            
            <h4>Wake Visualization and Analysis</h4>
            <div class="code-block">
                <pre><code># Visualize wake effects
def plot_horizontal_plane(fi, wind_speed=8.0, wind_direction=270.0):
    """Plot horizontal wake visualization"""
    fi.reinitialize(wind_speed=[wind_speed], 
                   wind_direction=[wind_direction])
    fi.calculate_wake()
    
    # Get flow field
    hor_plane = fi.calculate_horizontal_plane(height=90.0)
    
    # Create figure
    fig, ax = plt.subplots(figsize=(12, 6))
    
    # Plot wake field
    wfct.visualization.visualize_cut_plane(hor_plane, ax=ax)
    
    # Add turbine locations
    for i, (x, y) in enumerate(zip(layout_x, layout_y)):
        circle = plt.Circle((x, y), 63, fill=False, color='white', linewidth=2)
        ax.add_patch(circle)
        ax.text(x, y+100, f'T{i+1}', ha='center', color='white')
    
    ax.set_xlabel('x (m)')
    ax.set_ylabel('y (m)')
    ax.set_title(f'Wake Flow Field at Hub Height\n' + 
                f'Wind: {wind_speed} m/s @ {wind_direction}¬∞')
    plt.tight_layout()
    return fig

# Generate wake deficit profiles
def extract_wake_profiles(fi, turbine_idx=0, distances=[1, 3, 5, 7, 10]):
    """Extract wake profiles at different downstream distances"""
    profiles = {}
    
    for d in distances:
        x_loc = layout_x[turbine_idx] + d * 126  # D = 126m
        y_range = np.linspace(-200, 200, 100)
        
        velocities = []
        for y in y_range:
            u = fi.get_flow_field_velocity([x_loc], [y], [90.0])
            velocities.append(u[0, 0, 0])
        
        profiles[f'{d}D'] = {
            'y': y_range,
            'u': np.array(velocities),
            'deficit': 1 - np.array(velocities) / wind_speed
        }
    
    return profiles</code></pre>
            </div>
            
            <p><strong>FLORIS advantages for engineering analysis:</strong></p>
            <ul>
                <li>Fast computation enables optimization studies</li>
                <li>Built-in wake steering and control algorithms</li>
                <li>Validated against field data from multiple wind farms</li>
                <li>Easy integration with uncertainty quantification</li>
                <li>Supports various wake model formulations</li>
            </ul>
        </div>

        <!-- Section 5: Layout Optimization -->
        <div class="section" id="layout">
            <h2>5. Wind Farm Layout Optimization</h2>
            
            <h3>5.1 Optimization Objectives</h3>
            <div class="info-box">
                <strong>Multi-objective optimization typically considers:</strong>
                <ul>
                    <li>Annual Energy Production (AEP) maximization</li>
                    <li>Wake loss minimization</li>
                    <li>Levelized Cost of Energy (LCOE) minimization</li>
                    <li>Grid connection cost minimization</li>
                    <li>Fatigue load minimization</li>
                    <li>Noise constraints satisfaction</li>
                </ul>
            </div>

            <h3>5.2 Optimization Algorithms</h3>
            <div class="plot-grid">
                <div class="plot-box">
                    <h4>Genetic Algorithm Progress</h4>
                    <canvas id="gaOptimization"></canvas>
                </div>
                <div class="plot-box">
                    <h4>Layout Patterns</h4>
                    <canvas id="layoutPatterns"></canvas>
                </div>
            </div>

            <h3>5.3 Constraint Handling</h3>
            <table class="table">
                <tr>
                    <th>Constraint Type</th>
                    <th>Typical Value</th>
                    <th>Implementation</th>
                </tr>
                <tr>
                    <td>Minimum Spacing</td>
                    <td>3-5 D crosswind, 5-10 D downwind</td>
                    <td>Hard constraint</td>
                </tr>
                <tr>
                    <td>Boundary Limits</td>
                    <td>Site-specific polygon</td>
                    <td>Hard constraint</td>
                </tr>
                <tr>
                    <td>Exclusion Zones</td>
                    <td>Shipping lanes, cables</td>
                    <td>Hard constraint</td>
                </tr>
                <tr>
                    <td>Water Depth</td>
                    <td>Technology dependent</td>
                    <td>Soft constraint (cost)</td>
                </tr>
                <tr>
                    <td>Grid Connection</td>
                    <td>Distance to shore/substation</td>
                    <td>Soft constraint (cost)</td>
                </tr>
            </table>
        </div>

        <!-- Section 6: AEP Calculation -->
        <div class="section" id="aep">
            <h2>6. Annual Energy Production (AEP)</h2>
            
            <h3>6.1 AEP Calculation Framework</h3>
            <div class="formula-large">
                AEP = 8760 √ó Œ£·µ¢‚±º [P(V·µ¢,Œ∏‚±º) √ó f(V·µ¢,Œ∏‚±º) √ó A]<br>
                where:<br>
                P = Power at wind speed V·µ¢ and direction Œ∏‚±º<br>
                f = Joint probability of wind conditions<br>
                A = Availability factor
            </div>

            <h3>6.2 Loss Factors</h3>
            <div class="plot-grid">
                <div class="plot-box">
                    <h4>Loss Cascade</h4>
                    <canvas id="lossCascade"></canvas>
                </div>
                <div class="plot-box">
                    <h4>Typical Loss Values</h4>
                    <table class="table">
                        <tr>
                            <th>Loss Type</th>
                            <th>Range (%)</th>
                        </tr>
                        <tr>
                            <td>Wake Effects</td>
                            <td>5-15</td>
                        </tr>
                        <tr>
                            <td>Availability</td>
                            <td>3-7</td>
                        </tr>
                        <tr>
                            <td>Electrical</td>
                            <td>2-3</td>
                        </tr>
                        <tr>
                            <td>Turbine Performance</td>
                            <td>1-3</td>
                        </tr>
                        <tr>
                            <td>Environmental</td>
                            <td>1-2</td>
                        </tr>
                        <tr>
                            <td>Curtailment</td>
                            <td>0-5</td>
                        </tr>
                    </table>
                </div>
            </div>

            <h3>6.3 Uncertainty in AEP</h3>
            <canvas id="aepUncertainty"></canvas>
        </div>

        <!-- ========== PART III: ADVANCED METHODS ========== -->
        <div class="section part-divider">
            <h2 style="text-align: center; color: #0066cc; font-size: 2em; margin: 40px 0;">Part III: Advanced Methods</h2>
            <p style="text-align: center; font-style: italic; margin-bottom: 40px;">Integration, uncertainty, and validation of modeling approaches</p>
        </div>

        <!-- Section 7: Model Coupling -->
        <div class="section" id="coupling">
            <h2>7. Model Coupling Approaches</h2>
            
            <h3>7.1 Meso-Micro Coupling</h3>
            <div class="info-box">
                <strong>Coupling Strategies:</strong>
                <ul>
                    <li><strong>One-way nesting:</strong> Mesoscale ‚Üí Microscale boundary conditions</li>
                    <li><strong>Two-way coupling:</strong> Feedback from micro to meso</li>
                    <li><strong>Offline coupling:</strong> Statistical downscaling</li>
                    <li><strong>Online coupling:</strong> Concurrent execution</li>
                </ul>
            </div>

            <h3>7.2 Coupling Workflow</h3>
            <canvas id="couplingWorkflow"></canvas>

            <h3>7.3 Wave-Atmosphere Coupling</h3>
            <div class="plot-grid">
                <div class="plot-box">
                    <h4>Wave Effects on Wind</h4>
                    <canvas id="waveCoupling"></canvas>
                </div>
                <div class="plot-box">
                    <h4>Coupling Parameters</h4>
                    <ul>
                        <li>Sea surface roughness</li>
                        <li>Momentum flux</li>
                        <li>Heat flux modifications</li>
                        <li>Spray generation</li>
                        <li>Wave breaking effects</li>
                    </ul>
                </div>
            </div>
            
            <h3>7.4 OpenFOAM for High-Fidelity LES</h3>
            <div class="info-box">
                <strong>When to use OpenFOAM:</strong> Complex terrain, detailed wake interactions, atmospheric stability effects, or validation of engineering models.
            </div>
            
            <div class="code-block">
                <pre><code>// Example: Actuator disc model in OpenFOAM
// constant/turbineProperties
turbines
{
    turbine1
    {
        baseLocation    (1000 0 0);
        tipRadius       63.0;
        hubHeight       90.0;
        
        thrust
        {
            data  // Ct vs wind speed
            (
                (3.0  0.0)   (8.0  0.88)
                (13.0 0.57)  (25.0 0.10)
            );
        }
    }
}

// Atmospheric boundary layer setup
Uref    8.0;     // Reference velocity
Zref    90.0;    // Hub height
z0      0.0002;  // Offshore roughness</code></pre>
            </div>
            
            <p><strong>Key features:</strong> Actuator disc/line models, atmospheric physics, LES turbulence, parallel scalability</p>
        </div>

        <!-- Section 8: Uncertainty Quantification -->
        <div class="section" id="uncertainty">
            <h2>8. Uncertainty Quantification</h2>
            
            <h3>8.1 Sources of Uncertainty</h3>
            <table class="table">
                <tr>
                    <th>Category</th>
                    <th>Source</th>
                    <th>Typical Magnitude</th>
                    <th>Reduction Method</th>
                </tr>
                <tr>
                    <td rowspan="3">Input Data</td>
                    <td>Measurement uncertainty</td>
                    <td>2-3%</td>
                    <td>Better instrumentation</td>
                </tr>
                <tr>
                    <td>Spatial representativeness</td>
                    <td>3-5%</td>
                    <td>Multiple locations</td>
                </tr>
                <tr>
                    <td>Temporal variability</td>
                    <td>5-10%</td>
                    <td>Longer records</td>
                </tr>
                <tr>
                    <td rowspan="3">Model</td>
                    <td>Physical parameterizations</td>
                    <td>3-5%</td>
                    <td>Ensemble runs</td>
                </tr>
                <tr>
                    <td>Numerical discretization</td>
                    <td>1-2%</td>
                    <td>Grid refinement</td>
                </tr>
                <tr>
                    <td>Boundary conditions</td>
                    <td>2-4%</td>
                    <td>Sensitivity analysis</td>
                </tr>
            </table>

            <h3>8.2 Uncertainty Propagation</h3>
            <canvas id="uncertaintyProp"></canvas>

            <h3>8.3 Ensemble Modeling</h3>
            <div class="plot-box">
                <h4>Ensemble Spread</h4>
                <canvas id="ensembleSpread"></canvas>
            </div>
        </div>

        <!-- Section 9: Model Validation -->
        <div class="section" id="validation">
            <h2>9. Model Validation</h2>
            
            <h3>9.1 Validation Metrics</h3>
            <div class="formula">
                Bias: BIAS = (1/n)Œ£(Model - Obs)<br>
                RMSE: RMSE = ‚àö[(1/n)Œ£(Model - Obs)¬≤]<br>
                Correlation: r = Œ£[(M-MÃÑ)(O-≈å)] / ‚àö[Œ£(M-MÃÑ)¬≤Œ£(O-≈å)¬≤]
            </div>

            <h3>9.2 Validation Best Practices</h3>
            <div class="warning-box">
                <strong>Key Principles:</strong>
                <ul>
                    <li>Use independent data for validation (not used in calibration)</li>
                    <li>Validate at multiple heights and locations</li>
                    <li>Check both mean and turbulent quantities</li>
                    <li>Assess model performance across stability regimes</li>
                    <li>Document all assumptions and limitations</li>
                </ul>
            </div>

            <h3>9.3 Validation Results Example</h3>
            <div class="plot-grid">
                <div class="plot-box">
                    <h4>Model vs Observations</h4>
                    <canvas id="modelValidation"></canvas>
                </div>
                <div class="plot-box">
                    <h4>Error Statistics</h4>
                    <canvas id="errorStats"></canvas>
                </div>
            </div>
        </div>

        <!-- Summary -->
        <div class="section">
            <h2>üìù Chapter Summary</h2>
            <div class="success-box">
                <h3>Key Modeling Concepts:</h3>
                <ul>
                    <li>Multi-scale modeling is essential for offshore wind assessment</li>
                    <li>Each scale requires different approaches and assumptions</li>
                    <li>Wake modeling significantly impacts energy predictions</li>
                    <li>Layout optimization is a complex multi-objective problem</li>
                    <li>Model coupling improves accuracy but increases complexity</li>
                    <li>Uncertainty quantification is crucial for risk assessment</li>
                    <li>Thorough validation builds confidence in results</li>
                </ul>
            </div>

            <div class="info-box">
                <h3>Modeling Workflow:</h3>
                <ol>
                    <li>Define objectives and constraints</li>
                    <li>Select appropriate model scales and types</li>
                    <li>Configure domains and parameters</li>
                    <li>Run simulations with quality checks</li>
                    <li>Post-process and analyze results</li>
                    <li>Quantify uncertainties</li>
                    <li>Validate against measurements</li>
                    <li>Document assumptions and limitations</li>
                </ol>
            </div>
        </div>
    </div>

    <footer class="footer">
        <p>¬© 2024 Offshore Wind Analysis Textbook | Modeling Chapter</p>
        <p>
            <a href="measurement.html">‚Üê Previous: Measurements</a> | 
            <a href="data-processing.html">Next: Data Processing ‚Üí</a>
        </p>
    </footer>

    <script>
        // Chart.js visualizations
        document.addEventListener('DOMContentLoaded', function() {
            // Grid Resolution Effects
            new Chart('gridResolution', {
                type: 'line',
                data: {
                    labels: [100, 50, 25, 10, 5, 2, 1, 0.5, 0.2],
                    datasets: [
                        {
                            label: 'Resolved Features',
                            data: [10, 20, 35, 50, 65, 80, 90, 95, 98],
                            borderColor: 'rgb(76, 175, 80)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Computational Cost',
                            data: [1, 2, 5, 20, 50, 200, 500, 2000, 10000],
                            borderColor: 'rgb(244, 67, 54)',
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Resolution vs Features & Cost' }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Grid Resolution (km)' },
                            type: 'logarithmic',
                            reverse: true
                        },
                        y: { 
                            title: { display: true, text: 'Resolved Features (%)' },
                            position: 'left'
                        },
                        y1: {
                            title: { display: true, text: 'Relative Cost' },
                            position: 'right',
                            type: 'logarithmic',
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });

            // WRF Domains
            const wrfCanvas = document.getElementById('wrfDomains');
            const wrfCtx = wrfCanvas.getContext('2d');
            
            // Background
            wrfCtx.fillStyle = '#e3f2fd';
            wrfCtx.fillRect(0, 0, 400, 300);
            
            // Domain boxes
            const domains = [
                {x: 20, y: 20, w: 360, h: 260, color: 'rgba(255, 99, 132, 0.3)', label: 'd01: 9km'},
                {x: 80, y: 60, w: 240, h: 180, color: 'rgba(54, 162, 235, 0.3)', label: 'd02: 3km'},
                {x: 140, y: 100, w: 120, h: 100, color: 'rgba(255, 206, 86, 0.3)', label: 'd03: 1km'},
                {x: 170, y: 130, w: 60, h: 40, color: 'rgba(75, 192, 192, 0.3)', label: 'd04: 333m'}
            ];
            
            domains.forEach(domain => {
                wrfCtx.fillStyle = domain.color;
                wrfCtx.fillRect(domain.x, domain.y, domain.w, domain.h);
                wrfCtx.strokeStyle = domain.color.replace('0.3', '1');
                wrfCtx.strokeRect(domain.x, domain.y, domain.w, domain.h);
                
                wrfCtx.fillStyle = '#333';
                wrfCtx.font = '12px Arial';
                wrfCtx.fillText(domain.label, domain.x + 5, domain.y + 15);
            });
            
            // Wind farm location
            wrfCtx.fillStyle = '#f44336';
            wrfCtx.beginPath();
            wrfCtx.arc(200, 150, 5, 0, 2 * Math.PI);
            wrfCtx.fill();
            
            wrfCtx.font = 'bold 14px Arial';
            wrfCtx.fillText('Nested WRF Domains', 120, 290);

            // WRF Interpolation
            new Chart('wrfInterpolation', {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Model Levels',
                            data: [
                                {x: 8.5, y: 10}, {x: 9.0, y: 30}, {x: 9.5, y: 50},
                                {x: 10.0, y: 80}, {x: 10.5, y: 120}, {x: 11.0, y: 160}
                            ],
                            backgroundColor: 'rgb(33, 150, 243)',
                            pointRadius: 6
                        },
                        {
                            label: 'Interpolated',
                            data: [{x: 10.3, y: 100}],
                            backgroundColor: 'rgb(255, 99, 132)',
                            pointRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Hub Height Interpolation' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Wind Speed (m/s)' } },
                        y: { title: { display: true, text: 'Height (m)' } }
                    }
                }
            });

            // Temporal Downscaling
            new Chart('temporalDownscale', {
                type: 'line',
                data: {
                    labels: Array.from({length: 48}, (_, i) => i * 0.5),
                    datasets: [
                        {
                            label: '3-hourly WRF',
                            data: Array.from({length: 48}, (_, i) => {
                                if (i % 6 === 0) return 8 + 2 * Math.sin(i * 0.26);
                                return null;
                            }),
                            borderColor: 'rgb(244, 67, 54)',
                            pointRadius: 4,
                            showLine: false
                        },
                        {
                            label: '10-min Interpolated',
                            data: Array.from({length: 48}, (_, i) => 
                                8 + 2 * Math.sin(i * 0.26) + (Math.random() - 0.5) * 0.5
                            ),
                            borderColor: 'rgb(76, 175, 80)',
                            borderWidth: 1,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Temporal Downscaling' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Time (hours)' } },
                        y: { title: { display: true, text: 'Wind Speed (m/s)' } }
                    }
                }
            });

            // Mesh Refinement
            const meshCanvas = document.getElementById('meshRefinement');
            const meshCtx = meshCanvas.getContext('2d');
            
            meshCtx.fillStyle = '#f0f0f0';
            meshCtx.fillRect(0, 0, 400, 300);
            
            // Draw mesh with refinement
            meshCtx.strokeStyle = '#999';
            meshCtx.lineWidth = 0.5;
            
            // Coarse mesh
            for (let x = 0; x < 400; x += 40) {
                meshCtx.beginPath();
                meshCtx.moveTo(x, 0);
                meshCtx.lineTo(x, 300);
                meshCtx.stroke();
            }
            for (let y = 0; y < 300; y += 40) {
                meshCtx.beginPath();
                meshCtx.moveTo(0, y);
                meshCtx.lineTo(400, y);
                meshCtx.stroke();
            }
            
            // Medium refinement
            meshCtx.strokeStyle = '#666';
            for (let x = 120; x <= 280; x += 20) {
                meshCtx.beginPath();
                meshCtx.moveTo(x, 80);
                meshCtx.lineTo(x, 220);
                meshCtx.stroke();
            }
            for (let y = 80; y <= 220; y += 20) {
                meshCtx.beginPath();
                meshCtx.moveTo(120, y);
                meshCtx.lineTo(280, y);
                meshCtx.stroke();
            }
            
            // Fine refinement
            meshCtx.strokeStyle = '#333';
            for (let x = 180; x <= 220; x += 5) {
                meshCtx.beginPath();
                meshCtx.moveTo(x, 140);
                meshCtx.lineTo(x, 160);
                meshCtx.stroke();
            }
            for (let y = 140; y <= 160; y += 5) {
                meshCtx.beginPath();
                meshCtx.moveTo(180, y);
                meshCtx.lineTo(220, y);
                meshCtx.stroke();
            }
            
            // Turbine
            meshCtx.fillStyle = '#f44336';
            meshCtx.fillRect(195, 145, 10, 10);
            
            meshCtx.fillStyle = '#333';
            meshCtx.font = 'bold 14px Arial';
            meshCtx.fillText('Adaptive Mesh Refinement', 100, 20);

            // Wake Deficit
            new Chart('wakeDeficit', {
                type: 'line',
                data: {
                    labels: Array.from({length: 20}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Centerline',
                            data: Array.from({length: 20}, (_, i) => 
                                i === 0 ? 0.4 : 0.4 * Math.pow(1 / (1 + 0.075 * i), 2)
                            ),
                            borderColor: 'rgb(255, 99, 132)'
                        },
                        {
                            label: 'r = 0.5D',
                            data: Array.from({length: 20}, (_, i) => 
                                i === 0 ? 0.3 : 0.3 * Math.pow(1 / (1 + 0.075 * i), 2) * 0.7
                            ),
                            borderColor: 'rgb(54, 162, 235)'
                        },
                        {
                            label: 'r = 1.0D',
                            data: Array.from({length: 20}, (_, i) => 
                                i === 0 ? 0.1 : 0.1 * Math.pow(1 / (1 + 0.075 * i), 2) * 0.4
                            ),
                            borderColor: 'rgb(255, 206, 86)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Wake Velocity Deficit' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Distance (D)' } },
                        y: { 
                            title: { display: true, text: 'Velocity Deficit' },
                            min: 0,
                            max: 0.5
                        }
                    }
                }
            });

            // Wake Expansion
            new Chart('wakeExpansion', {
                type: 'line',
                data: {
                    labels: Array.from({length: 20}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Wake Radius',
                            data: Array.from({length: 20}, (_, i) => 0.5 + 0.075 * i),
                            borderColor: 'rgb(76, 175, 80)',
                            backgroundColor: 'rgba(76, 175, 80, 0.2)',
                            fill: '+1'
                        },
                        {
                            label: 'Wake Radius',
                            data: Array.from({length: 20}, (_, i) => -(0.5 + 0.075 * i)),
                            borderColor: 'rgb(76, 175, 80)',
                            backgroundColor: 'rgba(76, 175, 80, 0.2)',
                            fill: '-1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Wake Expansion' },
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Distance (D)' } },
                        y: { 
                            title: { display: true, text: 'Radius (D)' },
                            min: -2,
                            max: 2
                        }
                    }
                }
            });

            // Wake Comparison
            new Chart('wakeComparison', {
                type: 'line',
                data: {
                    labels: Array.from({length: 30}, (_, i) => i * 0.5),
                    datasets: [
                        {
                            label: 'Jensen',
                            data: Array.from({length: 30}, (_, i) => {
                                const x = i * 0.5;
                                return x === 0 ? 1 : 1 - 2 * 0.33 / Math.pow(1 + 0.04 * x, 2);
                            }),
                            borderColor: 'rgb(255, 99, 132)'
                        },
                        {
                            label: 'Gaussian',
                            data: Array.from({length: 30}, (_, i) => {
                                const x = i * 0.5;
                                const sigma = 0.5 + 0.08 * x;
                                return x === 0 ? 1 : 1 - 0.5 * Math.exp(-0.5 / (sigma * sigma));
                            }),
                            borderColor: 'rgb(54, 162, 235)'
                        },
                        {
                            label: 'LES Data',
                            data: Array.from({length: 30}, (_, i) => {
                                const x = i * 0.5;
                                return x === 0 ? 1 : 0.4 + 0.6 * (1 + 0.2 * Math.sin(x)) / (1 + 0.05 * x);
                            }),
                            borderColor: 'rgb(75, 192, 192)',
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Wake Model Comparison (Centerline)' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Distance (D)' } },
                        y: { 
                            title: { display: true, text: 'Normalized Velocity' },
                            min: 0.3,
                            max: 1.1
                        }
                    }
                }
            });

            // GA Optimization
            new Chart('gaOptimization', {
                type: 'line',
                data: {
                    labels: Array.from({length: 50}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Best Fitness',
                            data: Array.from({length: 50}, (_, i) => 
                                0.85 + 0.13 * (1 - Math.exp(-i / 10))
                            ),
                            borderColor: 'rgb(76, 175, 80)'
                        },
                        {
                            label: 'Mean Fitness',
                            data: Array.from({length: 50}, (_, i) => 
                                0.75 + 0.15 * (1 - Math.exp(-i / 15))
                            ),
                            borderColor: 'rgb(33, 150, 243)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Genetic Algorithm Convergence' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Generation' } },
                        y: { 
                            title: { display: true, text: 'Normalized AEP' },
                            min: 0.7,
                            max: 1.0
                        }
                    }
                }
            });

            // Layout Patterns
            const layoutCanvas = document.getElementById('layoutPatterns');
            const layoutCtx = layoutCanvas.getContext('2d');
            
            layoutCtx.fillStyle = '#e3f2fd';
            layoutCtx.fillRect(0, 0, 400, 300);
            
            // Regular grid
            layoutCtx.fillStyle = 'rgb(255, 99, 132)';
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    layoutCtx.beginPath();
                    layoutCtx.arc(50 + i * 30, 50 + j * 30, 4, 0, 2 * Math.PI);
                    layoutCtx.fill();
                }
            }
            layoutCtx.fillStyle = '#333';
            layoutCtx.font = '12px Arial';
            layoutCtx.fillText('Regular', 45, 150);
            
            // Optimized
            const optPositions = [
                {x: 200, y: 40}, {x: 170, y: 70}, {x: 230, y: 80},
                {x: 160, y: 110}, {x: 210, y: 120}, {x: 250, y: 100},
                {x: 180, y: 140}, {x: 240, y: 140}
            ];
            layoutCtx.fillStyle = 'rgb(76, 175, 80)';
            optPositions.forEach(pos => {
                layoutCtx.beginPath();
                layoutCtx.arc(pos.x, pos.y, 4, 0, 2 * Math.PI);
                layoutCtx.fill();
            });
            layoutCtx.fillStyle = '#333';
            layoutCtx.fillText('Optimized', 195, 150);
            
            // Prevailing wind arrow
            layoutCtx.strokeStyle = '#666';
            layoutCtx.lineWidth = 2;
            layoutCtx.beginPath();
            layoutCtx.moveTo(320, 200);
            layoutCtx.lineTo(320, 250);
            layoutCtx.moveTo(310, 240);
            layoutCtx.lineTo(320, 250);
            layoutCtx.lineTo(330, 240);
            layoutCtx.stroke();
            layoutCtx.fillText('Wind', 305, 270);
            
            layoutCtx.font = 'bold 14px Arial';
            layoutCtx.fillText('Layout Comparison', 130, 20);

            // Loss Cascade
            new Chart('lossCascade', {
                type: 'bar',
                data: {
                    labels: ['Gross', 'Wake', 'Avail.', 'Elec.', 'Perf.', 'Env.', 'Curt.', 'Net'],
                    datasets: [{
                        label: 'Energy (GWh/yr)',
                        data: [100, 90, 85, 83, 81, 80, 78, 78],
                        backgroundColor: [
                            'rgba(76, 175, 80, 0.8)',
                            'rgba(33, 150, 243, 0.6)',
                            'rgba(33, 150, 243, 0.6)',
                            'rgba(33, 150, 243, 0.6)',
                            'rgba(33, 150, 243, 0.6)',
                            'rgba(33, 150, 243, 0.6)',
                            'rgba(33, 150, 243, 0.6)',
                            'rgba(255, 152, 0, 0.8)'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Energy Loss Cascade' }
                    },
                    scales: {
                        y: { 
                            title: { display: true, text: 'Annual Energy (GWh)' },
                            min: 0,
                            max: 110
                        }
                    }
                }
            });

            // AEP Uncertainty
            new Chart('aepUncertainty', {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => 70 + i * 0.4),
                    datasets: [
                        {
                            label: 'P50',
                            data: Array.from({length: 100}, (_, i) => {
                                const x = 70 + i * 0.4;
                                return 100 * Math.exp(-Math.pow(x - 100, 2) / 200);
                            }),
                            borderColor: 'rgb(33, 150, 243)',
                            backgroundColor: 'rgba(33, 150, 243, 0.2)',
                            fill: false
                        },
                        {
                            label: 'P90',
                            data: Array.from({length: 100}, (_, i) => {
                                const x = 70 + i * 0.4;
                                return 100 * Math.exp(-Math.pow(x - 92, 2) / 200);
                            }),
                            borderColor: 'rgb(255, 152, 0)',
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'AEP Probability Distribution' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'AEP (GWh/yr)' } },
                        y: { title: { display: true, text: 'Probability Density' } }
                    }
                }
            });

            // Coupling Workflow
            const couplingCanvas = document.getElementById('couplingWorkflow');
            const couplingCtx = couplingCanvas.getContext('2d');
            
            couplingCtx.fillStyle = '#f0f0f0';
            couplingCtx.fillRect(0, 0, 400, 300);
            
            // Boxes
            const boxes = [
                {x: 50, y: 30, w: 100, h: 40, text: 'Global NWP', color: '#bbdefb'},
                {x: 50, y: 100, w: 100, h: 40, text: 'Mesoscale', color: '#c8e6c9'},
                {x: 50, y: 170, w: 100, h: 40, text: 'Microscale', color: '#ffe0b2'},
                {x: 250, y: 100, w: 100, h: 40, text: 'Wave Model', color: '#f8bbd0'},
                {x: 150, y: 240, w: 100, h: 40, text: 'Wind Farm', color: '#d1c4e9'}
            ];
            
            boxes.forEach(box => {
                couplingCtx.fillStyle = box.color;
                couplingCtx.fillRect(box.x, box.y, box.w, box.h);
                couplingCtx.strokeStyle = '#666';
                couplingCtx.strokeRect(box.x, box.y, box.w, box.h);
                
                couplingCtx.fillStyle = '#333';
                couplingCtx.font = '12px Arial';
                couplingCtx.textAlign = 'center';
                couplingCtx.fillText(box.text, box.x + box.w/2, box.y + 25);
            });
            
            // Arrows
            couplingCtx.strokeStyle = '#666';
            couplingCtx.lineWidth = 2;
            
            // NWP to Meso
            couplingCtx.beginPath();
            couplingCtx.moveTo(100, 70);
            couplingCtx.lineTo(100, 100);
            couplingCtx.stroke();
            
            // Meso to Micro
            couplingCtx.beginPath();
            couplingCtx.moveTo(100, 140);
            couplingCtx.lineTo(100, 170);
            couplingCtx.stroke();
            
            // Wave to Meso
            couplingCtx.beginPath();
            couplingCtx.moveTo(250, 120);
            couplingCtx.lineTo(150, 120);
            couplingCtx.stroke();
            
            // Micro to Wind Farm
            couplingCtx.beginPath();
            couplingCtx.moveTo(100, 210);
            couplingCtx.lineTo(150, 250);
            couplingCtx.stroke();
            
            couplingCtx.textAlign = 'left';
            couplingCtx.font = 'bold 14px Arial';
            couplingCtx.fillText('Model Coupling Framework', 100, 20);

            // Wave Coupling
            new Chart('waveCoupling', {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'z0 vs Wave Age',
                        data: Array.from({length: 50}, () => {
                            const waveAge = Math.random() * 2 + 0.5;
                            const z0 = 0.0002 * (1 + 2 * Math.exp(-waveAge));
                            return {x: waveAge, y: z0};
                        }),
                        backgroundColor: 'rgba(33, 150, 243, 0.5)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Wave-Dependent Roughness' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Wave Age (cp/u*)' } },
                        y: { 
                            title: { display: true, text: 'z0 (m)' },
                            type: 'logarithmic'
                        }
                    }
                }
            });

            // Uncertainty Propagation
            new Chart('uncertaintyProp', {
                type: 'bar',
                data: {
                    labels: ['Wind', 'Shear', 'TI', 'Losses', 'Model', 'Total'],
                    datasets: [{
                        label: 'Uncertainty (%)',
                        data: [4, 2, 3, 3, 4, 7.5],
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.6)',
                            'rgba(54, 162, 235, 0.6)',
                            'rgba(255, 206, 86, 0.6)',
                            'rgba(75, 192, 192, 0.6)',
                            'rgba(153, 102, 255, 0.6)',
                            'rgba(255, 159, 64, 0.8)'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Uncertainty Components' }
                    },
                    scales: {
                        y: { 
                            title: { display: true, text: 'Standard Deviation (%)' },
                            min: 0,
                            max: 10
                        }
                    }
                }
            });

            // Ensemble Spread
            new Chart('ensembleSpread', {
                type: 'line',
                data: {
                    labels: Array.from({length: 48}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Ensemble Mean',
                            data: Array.from({length: 48}, (_, i) => 
                                10 + 3 * Math.sin(i * 0.13) + 0.5 * Math.sin(i * 0.5)
                            ),
                            borderColor: 'rgb(255, 99, 132)',
                            borderWidth: 3
                        },
                        ...Array.from({length: 5}, (_, j) => ({
                            label: `Member ${j+1}`,
                            data: Array.from({length: 48}, (_, i) => 
                                10 + 3 * Math.sin(i * 0.13 + j * 0.2) + 
                                0.5 * Math.sin(i * 0.5) + (Math.random() - 0.5) * 2
                            ),
                            borderColor: 'rgba(33, 150, 243, 0.3)',
                            borderWidth: 1,
                            pointRadius: 0
                        }))
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Ensemble Model Spread' },
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Forecast Hour' } },
                        y: { title: { display: true, text: 'Wind Speed (m/s)' } }
                    }
                }
            });

            // Model Validation
            new Chart('modelValidation', {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Model vs Mast',
                        data: Array.from({length: 100}, () => {
                            const obs = Math.random() * 20 + 2;
                            const model = obs + (Math.random() - 0.5) * 3 + 0.5;
                            return {x: obs, y: model};
                        }),
                        backgroundColor: 'rgba(33, 150, 243, 0.5)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Model Validation Scatter' }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Observed Wind Speed (m/s)' },
                            min: 0,
                            max: 25
                        },
                        y: { 
                            title: { display: true, text: 'Modeled Wind Speed (m/s)' },
                            min: 0,
                            max: 25
                        }
                    }
                }
            });

            // Turbulence Evolution
            new Chart('turbulenceEvolution', {
                type: 'line',
                data: {
                    labels: Array.from({length: 20}, (_, i) => i),
                    datasets: [
                        {
                            label: 'Wake TI',
                            data: Array.from({length: 20}, (_, i) => {
                                const ambient = 0.06;
                                const added = 0.15 * Math.exp(-i / 5);
                                return ambient + added;
                            }),
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            fill: true
                        },
                        {
                            label: 'Ambient TI',
                            data: Array.from({length: 20}, () => 0.06),
                            borderColor: 'rgb(54, 162, 235)',
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Turbulence Intensity Evolution' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Distance (D)' } },
                        y: { 
                            title: { display: true, text: 'Turbulence Intensity' },
                            min: 0,
                            max: 0.25
                        }
                    }
                }
            });

            // Turbulence Model Comparison
            new Chart('turbulenceComparison', {
                type: 'line',
                data: {
                    labels: Array.from({length: 15}, (_, i) => i + 1),
                    datasets: [
                        {
                            label: 'k-Œµ-fP',
                            data: [0.20, 0.18, 0.16, 0.14, 0.12, 0.11, 0.10, 0.09, 0.085, 0.08, 0.075, 0.07, 0.068, 0.065, 0.063],
                            borderColor: 'rgb(76, 175, 80)',
                            borderWidth: 2
                        },
                        {
                            label: 'Standard k-Œµ',
                            data: [0.20, 0.17, 0.14, 0.12, 0.10, 0.09, 0.08, 0.075, 0.07, 0.068, 0.065, 0.063, 0.061, 0.06, 0.06],
                            borderColor: 'rgb(33, 150, 243)',
                            borderDash: [5, 5]
                        },
                        {
                            label: 'k-œâ-SST',
                            data: [0.20, 0.16, 0.13, 0.11, 0.095, 0.085, 0.077, 0.072, 0.068, 0.065, 0.063, 0.061, 0.06, 0.059, 0.058],
                            borderColor: 'rgb(255, 152, 0)',
                            borderDash: [10, 5]
                        },
                        {
                            label: 'Field Data',
                            data: [0.20, 0.175, 0.155, 0.135, 0.115, 0.105, 0.095, 0.087, 0.081, 0.076, 0.072, 0.069, 0.066, 0.064, 0.062],
                            borderColor: 'rgb(255, 99, 132)',
                            borderWidth: 0,
                            pointRadius: 4,
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Turbulence Model Performance in Wake' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Distance Downstream (D)' } },
                        y: { 
                            title: { display: true, text: 'Turbulence Intensity' },
                            min: 0.05,
                            max: 0.22
                        }
                    }
                }
            });

            // Error Statistics
            new Chart('errorStats', {
                type: 'bar',
                data: {
                    labels: ['Bias', 'RMSE', 'MAE', 'r¬≤'],
                    datasets: [
                        {
                            label: 'Mesoscale',
                            data: [0.5, 1.8, 1.2, 0.85],
                            backgroundColor: 'rgba(255, 99, 132, 0.6)'
                        },
                        {
                            label: 'Microscale',
                            data: [0.2, 1.2, 0.8, 0.92],
                            backgroundColor: 'rgba(54, 162, 235, 0.6)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Model Error Statistics' }
                    },
                    scales: {
                        y: { 
                            title: { display: true, text: 'Value' }
                        }
                    }
                }
            });
        });
    </script>
    <!-- Modal for enlarged charts -->
    <div id="chartModal" class="modal">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <div class="modal-canvas-container">
                <canvas id="modalCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Modal functionality
        let modal = document.getElementById('chartModal');
        let modalCanvas = document.getElementById('modalCanvas');
        let modalClose = document.querySelector('.modal-close');
        let activeChart = null;

        // Function to open modal with chart
        function openChartModal(originalCanvas) {
            // Special handling for custom drawn canvases
            const customCanvases = ['wrfDomains', 'meshRefinement', 'layoutPatterns', 'couplingWorkflow'];
            if (customCanvases.includes(originalCanvas.id)) {
                // For custom drawn canvases, just copy the image
                modal.style.display = 'block';
                modalCanvas.width = 800;
                modalCanvas.height = 600;
                const modalCtx = modalCanvas.getContext('2d');
                modalCtx.fillStyle = '#fff';
                modalCtx.fillRect(0, 0, modalCanvas.width, modalCanvas.height);
                modalCtx.drawImage(originalCanvas, 0, 0, modalCanvas.width, modalCanvas.height);
                return;
            }

            // Get the chart instance from the original canvas
            let originalChart = Chart.getChart(originalCanvas);
            if (!originalChart) return;

            modal.style.display = 'block';
            
            // Clone the chart configuration
            let config = JSON.parse(JSON.stringify(originalChart.config));
            
            // Adjust size for modal
            modalCanvas.width = 800;
            modalCanvas.height = 600;
            
            // Destroy previous chart if exists
            if (activeChart) {
                activeChart.destroy();
            }
            
            // Create new chart in modal
            activeChart = new Chart(modalCanvas, config);
        }

        // Close modal
        modalClose.onclick = function() {
            modal.style.display = 'none';
            if (activeChart) {
                activeChart.destroy();
                activeChart = null;
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
                if (activeChart) {
                    activeChart.destroy();
                    activeChart = null;
                }
            }
        }

        // Add click handlers to all canvases after charts are loaded
        setTimeout(() => {
            document.querySelectorAll('canvas').forEach(canvas => {
                if (canvas.id !== 'modalCanvas') {
                    canvas.classList.add('clickable-chart');
                    canvas.addEventListener('click', function() {
                        openChartModal(this);
                    });
                }
            });
        }, 500);
    </script>
</body>
</html>